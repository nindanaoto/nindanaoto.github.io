---
marp: true
---
<!--
theme: default
size: 16:9
paginate: true
footer : ![](../../seccamp/image/ccbysa.png) [licence](https://creativecommons.org/licenses/by-sa/4.0/)
style: |
  h1, h2, h3, h4, h5, header, footer {
        color: white;
    }
  section {
    background-color: #505050;
    color:white
  }
  table{
      color:black
  }
  code{
    color:black
  }
    a {
    font-weight:bold;
    color:#F00;
  }
-->

<!-- page_number: true -->

# Introduction to TFHE Implementation

## 5.Identity Key Switching

Kotaro Matsuoka

---

## Position of Explained Content in HomNAND

![](../../seccamp/image/IdentityKeySwitchingHomNANDdiagramreversed.png)

---

## What is Identity Key Switching

- "Key Switching" generally refers to changing the secret key without decrypting ciphertext
  - Generally, a [Lipschitz continuous](https://en.wikipedia.org/wiki/Lipschitz_continuity) function is applied simultaneously with changing the secret key
    - Mostly linear functions
- "Identity Key Switching" here is the operation of switching TLWElvl1 to TLWElvl0
  - lvl1 and lvl0 have different keys
  - "Identity" because the identity function is applied

---

## Idea of Identity Key Switching

- Here, we write the TLWElvl1 key as $\mathbf{S}$ (vector of $s[X]$ coefficients)
- Compute $b-\mathbf{a}â‹… \mathbf{S}$ of TLWElvl1 on ciphertext using TLWElvl0
- That is, let $(\mathbf{Ã£},bÌƒ)$ be the output TLWElvl0 and satisfy the following
$bÌƒ-\mathbf{Ã£}â‹…\mathbf{s} â‰ˆ b-\mathbf{a}â‹… \mathbf{S}$
  - This means making TLWElvl0 and plaintext match except for noise

---

## Naive Implementation of Identity Key Switching (Scaling Only)

- Although different from the paper, let's explain following the same flow as TRGSW
  - Actually, if $n$ is a power of 2, it can be done with ExternalProduct and SampleExtractIndex
    - Degree of freedom in parameter selection is significantly reduced (used in BFV and CKKS)
  - If you think of using TGSW instead of TRGSW, it's External Product itself
- $basebitâˆˆ\mathbb{Z}^+$ corresponds to $Bgbit$ in External Product
  - Scaling doesn't need to be a power of 2, but we assume it here for simplicity

---

- Let $\mathbf{KS}$ be such that $KS_{ij}$ is TLWElvl0 with plaintext $\frac{S_{ij}}{2^{basebit}}$
  - $i$ is vector dimension, $j$ is polynomial coefficient side
$(\mathbf{Ã£},bÌƒ) = (\mathbf{0},b)-âˆ‘^{N-1}_{i=0}âŒˆ2^{basebit}â‹…a_iâŒ‹â‹…KS_i$
  - This homomorphically computes $b-\mathbf{a}â‹… \mathbf{S}$, but noise is too large

---

## Decomposition-like Radix Expansion in Identity Key Switching

- Same as TRGSW, scaling alone won't work, so we also do Decomposition
  - Let the number of digits be $t$ (corresponding to $l$)

```
IdentityKeySwitching((ğš,b),ğŠğ’)
  roundoffset = 1 << (32 - (1 + basebit * t)) //for rounding
  bÌ„=b
  ğšÌ„ = 0âƒ—
  for i from 0 to t-1
    for j from 0 to kN - 1
      Ã¢áµ¢â±¼ = ((aâ±¼+roundoffset)>> (32 - (i+1)â‹…basebit))&(2áµ‡áµƒË¢áµ‰áµ‡â±áµ— - 1)
  for i from t-1 to 0
    for j from 0 to kN-1
      if Ã¢áµ¢â±¼ â‰¥ 2áµ‡áµƒË¢áµ‰áµ‡â±áµ—â»Â¹
        Ã¢áµ¢â±¼ -= 2áµ‡áµƒË¢áµ‰áµ‡â±áµ—
        Ã¢â‚áµ¢â‚‹â‚â‚â±¼ += 1
      (ğšÌ„,bÌ„) -= Ã¢áµ¢â±¼ â‹… KSáµ¢â±¼
  return (ğšÌ„,bÌ„)
```
---

## Specific Implementation of Identity Key Switching (Replace Multiplication with Element Selection)

- The previous slide's approach isn't bad
  - Unlike External Product, since it's a product with scalar integers, the values it can take are fairly limited
- Redefine $\mathbf{KS}$ so that $KS_{ijk}$ is TLWElvl0 with plaintext $\frac{kâ‹…S_i}{2^{(j+1)basebit}}$ ($k âˆˆ [1,2^{basebit-1}]$)
  - $\mathbf{KS}$ data size becomes $2^{basebit-1}$ times larger
  - Trade-off with reduced noise growth since multiplication is eliminated
- For the case $k=0$, no need to add, so no need to hold

---

## Specific Implementation of Identity Key Switching (Pseudocode)

```
IdentityKeySwitching((ğš,b),ğŠğ’)
  roundoffset = 1 << (32 - (1 + basebit * t)) //for rounding
  bÌ„=b
  ğšÌ„ = 0âƒ—
  for i from 0 to t-1
    for j from 0 to kN - 1
      Ã¢áµ¢â±¼ = ((aâ±¼+roundoffset)>> (32 - (i+1)â‹…basebit))&(2áµ‡áµƒË¢áµ‰áµ‡â±áµ— - 1)
  for i from t-1 to 0
    for j from 0 to kN-1
      if Ã¢áµ¢â±¼ â‰¥ 2áµ‡áµƒË¢áµ‰áµ‡â±áµ—â»Â¹
        Ã¢áµ¢â±¼ -= 2áµ‡áµƒË¢áµ‰áµ‡â±áµ—
        Ã¢â‚áµ¢â‚‹â‚â‚â±¼ += 1
      k = abs(Ã¢áµ¢â±¼)
      if Ã¢áµ¢â±¼ > 0
        (ğšÌ„,bÌ„) -= KSáµ¢â±¼â‚–
      else if Ã¢áµ¢â±¼ < 0
        (ğšÌ„,bÌ„) += KSáµ¢â±¼â‚–
  return (ğšÌ„,bÌ„)
```

---


## Identity Key Switching Parameters and Minimum Implementation

- $t = 5$, $basebit = 2$
- Identity Key Switching as explained here is the minimum

---

## Optimization Applicable to IKS

- Making part of the lvl1 key the lvl0 key simplifies computation
  - Since $n<kN$, make up to the $n$-th coefficient of $\mathbf{S}$ the lvl0 key
  - Just need to compute the difference with IKS
- This method is safe as far as no attack method has been found, but safety is unknown
