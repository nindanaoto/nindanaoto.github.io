---
marp: true
---
<!--
theme: default
size: 16:9
paginate: true
footer : ![](../../seccamp/image/ccbysa.png) [licence](https://creativecommons.org/licenses/by-sa/4.0/)
style: |
  h1, h2, h3, h4, h5, header, footer {
        color: white;
    }
  section {
    background-color: #505050;
    color:white
  }
  table{
      color:black
  }
  code{
    color:black
  }
    a {
    font-weight:bold;
    color:#F00;
  }
-->

<!-- page_number: true -->

# Introduction to TFHE Implementation

## 2.TRLWE & SampleExtractIndex

Kotaro Matsuoka

---

## Position of Explained Content in HomNAND

![](../../seccamp/image/TRLWEHomNANDdiagramreversed.png)

---

## What is TRLWE

- Stands for Torus Ring-LWE
- In TLWE, plaintext was scalar, but in TRLWE it becomes a polynomial
- "Ring" comes from being defined over a polynomial "ring"
  - Strictly speaking, Torus coefficient polynomials might not form a ring
    - Multiplication is not defined

---

## Polynomial Ring

- Let $N‚àà\mathbb{Z}^+$
- The polynomial ring used in TRLWE is the quotient ring formed by Torus coefficient polynomials divided by $X^N+1$
- This polynomial ring is denoted as $\mathbb{T}_N[X]$
- Since multiplication between Torus values cannot be defined, products of elements in $\mathbb{T}_N[X]$ also cannot be defined
- Since multiplication between integers and Torus can be defined, products with elements of $\mathbb{Z}_N[X]$ can be defined

---

## Multiplication on Polynomial Ring

- This is the heaviest operation in TFHE, so if you want to optimize, you should optimize here
  - Implementation using FFT (Fast Fourier Transform) or NTT (Number Theoretic Transform) is the fastest I know
- Here we deal with naive implementation (the optimal implementation I know is covered in Chapter 7)
  - What was covered in Exercise 2.1
- Just multiply two elements, take the remainder, and extract the part corresponding to the fractional part of coefficients

---

## Naieve Multiplication Algorithm

- Let inputs be $a[X]‚àà\mathbb{T}_N[X]$, $b[X]‚àà\mathbb{Z}_N[X]$
- $a[X]=\sum_{i=0}^{N-1}a_iX^i$, $a_i‚àà\mathbb{T}$

```
for i from 0 to N-1
  c·µ¢ = 0
for i from 0 to N-1
  for j from 0 to N-1
    if i+j<N
      c·µ¢‚Çä‚±º += a·µ¢‚ãÖb‚±º
    else
      c·µ¢‚Çä‚±º‚Çã‚Çô -= a·µ¢‚ãÖb‚±º (N subscript cannot be typed, so it's ‚Çô)
```

---

## Specific Construction of TRLWE (when plaintext is $\mathbb{T}_N[X]$)

- Three parameters determine encryption security: $N,k‚àà\mathbb{Z}^+$, $Œ±_{bk} \in \mathbb{R}^+$
  - Strictly speaking, only the case $k=1$ is TRLWE, and $k>1$ should be called TMLWE or TGLWE
    - In this lecture, we call them together as TRLWE
- $\mathbf{a}[X] ‚àà (\mathbb{T}_N[X])^k$, $b[X],m[X],e[X] \in \mathbb{T}_N[X]$, $\mathbf{s}[X] \in (\mathbb{B}^\pm_N[X])^k$
  - $\mathbb{B}^\pm = \{-1,0,1\}$ is generally called Ternary (notation is not standard)
  - Binary doesn't provide enough security, so we increase it
- $m[X]$ is plaintext, $\mathbf{a}[X]‚ÜêU_{(\mathbb{T}_N[X])^k}$, $e[X]‚Üê\mathcal{D}_{\mathbb{T}_N[X],Œ±_{bk}}$, $\mathbf{s}[X]‚ÜêU_{(\mathbb{B}_N[X])^k}$
- TRLWE ciphertext is $(\mathbf{a}[X],b[X])$, a vector of $k+1$ elements of polynomials of degree $N-1$, where $b[X]=\mathbf{a}[X]‚ãÖ \mathbf{s}[X]+ m[X] +e[X]$

---

- Since $b[X]-\mathbf{a}[X]‚ãÖ\mathbf{s}[X]=m[X]+e[X]$, if we somehow remove this $e[X]$, we can extract $m[X]$ and decrypt
- The larger $N,k,Œ±_{bk}$, the more secure ($Œ±_{bk}$ breaks ciphertext if too large)
- For the same security and data, TRLWE is smaller in size than TLWE (it is believed)

---

## Additive Homomorphism of TRLWE

- Since TLWE and TRLWE are very similar, additive homomorphism holds in the same way
- Consider two ciphertexts $(\mathbf{a}[X]_1,b[X]_1)$, $(\mathbf{a}[X]_2,b[X]_2)$
- Let their sum be $(\mathbf{a}[X]_1+\mathbf{a}[X]_2,b[X]_1+b[X]_2)$
- $b_1[X]+b_2[X]-(a_1[X]+a_2[X])‚ãÖs[X]=m_1[X]+m_2[X]+e_1[X]+e_2[X]$, and since $m_1[X]+m_2[X]$ appears, we see additive homomorphism
- Since the size is smaller than TLWE, addition can be done faster
  - Independent addition for each coefficient, so SIMD-like

---

## Specific Construction of TRLWE (when plaintext is $\mathbb{B}_N[X]$)

- This is also similar to TLWE
- Let $m[X] \in \mathbb{B}[X]$, $Œº=1/8 \in\mathbb{T}$
- $(Œº(2‚ãÖ m[X]-1[X])‚àà\mathbb{T}_N[X])$
- TRLWE ciphertext is $b[X]=\mathbf{a}[X]‚ãÖ \mathbf{s}[X]+Œº(2‚ãÖ m[X]-1[X])+e[X]$
- Decryption is $(1+\mathit{sgn}(b[X]-\mathbf{a}[X]‚ãÖ \mathbf{s}[X]))/2$ ($\mathit{sgn}$ is sign function acting on each coefficient)

---

## SampleExtractIndex

- Operation that decomposes TRLWE into $N$ TLWEs
- In terms of operation on plaintext, it corresponds to extracting coefficients of a polynomial
- TLWE discussed in Chapter 1 has $n$ elements in $\mathbf{a}$, but here it has $kN$ elements
  - When distinction is needed, we'll call the one from Chapter 1 TLWElvl0, and the one introduced here TLWElvl1
- Note that there are two keys
  - Making the two keys dependent can make computation a bit easier
    - https://eprint.iacr.org/2023/979 , https://eprint.iacr.org/2023/958
  - But for now, we treat them as independent for the general case
- In terms of security, this is important because if TLWE can be broken, TRLWE can be broken

---

## Specific Construction of SampleExtractIndex (Mathematical Expression)

- Basically, it comes out by staring at part of decryption, so let's change the expression and look at it
$$b[X]-\mathbf{a}[X]‚ãÖ \mathbf{s}[X]=\sum^{N-1}_{x=0} \{b_x-\sum_{l=0}^{k-1}[(\sum_{i+j=x,0‚â§i,j‚â§N-1}a_{li}‚ãÖs_{lj})+(\sum_{i+j=N+x,0‚â§i,j‚â§N-1}-a_{li}‚ãÖs_{lj})]\}X^x$$
- The minus in the third $\sum$ is because it's an operation on a quotient ring
- The basic idea is to fix $x$ to one value

---

- Then we can see that the TLWE expressing the $x$-th term of the plaintext polynomial is as follows

$$
\begin{aligned}
b'&=b_x\\
j\in[0,k)\\
a'_{ji}&=\begin{cases}
a_{j(x-i)}\ \mathrm{if}\ i‚â§x\\
-a_{j(N+x-i)}\ \mathrm{otherwise}
\end{cases}
\end{aligned}
$$

---

## Specific Construction of SampleExtractIndex (Pseudocode Expression)

```
SampleExtractIndex((ùêö[X],b[X]),x)
  bÃÑ = b‚Çì
  ùêöÃÑ = 0
  for j from 0 to k-1
    for i from 0 to x
      ƒÅ‚±º·µ¢ = a‚±º‚Çç‚Çì‚Çã·µ¢‚Çé
    for i from x+1 to N-1
      ƒÅ‚±º·µ¢ = -a‚±º‚Çç‚Çô‚Çä‚Çì‚Çã·µ¢‚Çé //N becomes lowercase because subscript doesn't work
  return (ùêöÃÑ,bÃÑ)
```

---

## About TRLWE Parameters

- $N=512$, $k=2$, $Œ±_{bk}=0.0000000342338787018369$, 32-bit fixed-point
  - If using C++20's _BitInt, etc., it should be reducible to about 27 bits
  - With CBD, $\eta$ becomes too large (over 1024?), so better not to use
    - If you can reduce fixed-point to less than 32 bits, $\eta$ also becomes smaller and usable
- Actually, no method is known to directly estimate TRLWE security
  - Because no attack utilizing the ring structure in TRLWE is known
  - Security estimation is done by converting to TLWE (weak estimation by sufficient condition)

---

## Why $X^N+1$?

- Actually, it doesn't have to be $X^N+1$
- If it can be factored, it can be decomposed into TRLWEs with smaller $N$, which is clearly vulnerable
- $X^N+1$ cannot be factored if $N$ is a power of 2
  - A type of [cyclotomic polynomial](https://en.wikipedia.org/wiki/Cyclotomic_polynomial)
  - Security proof doesn't break if it's a cyclotomic polynomial
    - https://eprint.iacr.org/2012/230
- Since it has only two non-zero terms, remainders are easy to take
  - Cases where 2 and 3 are the only factors of $N$ are also sometimes used
- Being able to speed up with FFT/NTT is also an advantage

---

## Minimum Implementation for TRLWE

- Encryption and decryption only need to work when plaintext is limited to binary coefficient polynomials
- SampleExtractIndex only uses the case $x=0$
- Addition of ciphertexts is used later, so it's good to hold data in a way that makes vector-like addition easy
- Parameters should be written so they can be easily changed later for higher versatility

---

## References

- [Reason for $X^N+1$](https://eprint.iacr.org/2012/235)
- [Security reduction for Ring LWE, etc.](https://eprint.iacr.org/2019/878)
