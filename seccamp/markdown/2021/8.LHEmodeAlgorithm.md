---
marp: true
---
<!-- 
theme: default
size: 16:9
paginate: true
footer : ![](../../image/ccbysa.png) [licence](https://creativecommons.org/licenses/by-sa/4.0/)
style: |
  h1, h2, h3, h4, h5, header, footer {
        color: white;
    }
  section {
    background-color: #505050;
    color:white
  }
  table{
      color:black
  }
  code{
    color:black
  }
    a {
    font-weight:bold;
    color:#F00;
  } 
-->

<!-- page_number: true -->

# TFHE実装入門

## 8.LHE mode Algorithm

松岡　航太郎


---

## 扱う内容(概要)

- 今までの話はHomNANDをどうやって作るかという話
  - これはTFHEのFHEとしての機能
- 今回扱うのはCMUXを使うことで達成できる機能について
  - TFHEのLHEとしての機能
  - Bootstrappingをしないのでノイズが増え続ける
  - $N$を大きくすれば同じセキュリティを達成するのに必要なノイズの最小値が小さくなるのでより多くの演算に耐えられる

---

## 扱う内容(目次)

1. Horizontal/Vertical Packing
  - CMUXでLUTを評価する
2. detWFA
  - CMUXでオートマトンを評価する
3. TBSR
  - CMUXで加算や乗算をより効率よく評価する

---

## LHE mode Algorithmの入出力

- CMUXのセレクタに入れるのはTRGSWだけ
  - 基本的に入力はTRGSWとして表現される
  - セレクタがPublicならCMUXの演算はいらないので自然といえば自然
- CMUXのデータ入力と出力はTRLWE
  - これはPublicなものとして自明な暗号文でもいいし暗号文として入力で渡してもいい

---

## CMUXでのLUTの評価

- まずはナイーブな場合を考える
  - $k$-bitのindexを受け取り、$N$bitの出力を返すLUTを考えよう
  - 入力は$k$個のTRGSW
  - $2^k$個のTRLWEにそれぞれのindexに対応した$N$bitを係数として入れておく
    - これをツリー状のCMUXで選択するだけで良い

---

## Horizontal Packing

- 同じ$k$-bitのindexを受け取る$m$個の関数が存在するとしよう
- もしこの関数達の出力bit数の和が$N$以下なら同じTRLWEにそれらの出力を詰めることで一回のLUTの評価で複数の関数を一度に評価できる
  - 例えば$m|N$でそれぞれの関数の出力bit数が$\frac{N}{m}$なら$i∈[0,m)$個目の関数が$[i\cdot\frac{N}{m},(i+1)⋅ \frac{N}{m})$次の係数を使えば良い

---

## Vertiacal Packing

- 評価する関数は1つだが、出力bit数が$\frac{N}{2^o},o∈ \mathbb{N}$の場合を考えよう
- このとき、1つのTRLWEに下位$o$bitが一致するindexに対応する$2^o$個の出力を詰めることができる
  - 上位$k-o$-bitに関してはツリー状のCMUXをやるので変わらない
  - 下位$o$-bitに関しては$X$のべき乗を掛けたものとCMUXする
  - TRLWE自体の数が減るのでメモリが減るしCMUXの数が減るので計算量も減る

---

## detWFA

- deterministic Weighted Finite Automata
  - 決定性重み付き有限オートマトン